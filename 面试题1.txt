一、es6有哪些新特性?
	1、let和cont关键字 2、变量的赋值结构 3、字符串，数值的扩展 4、数组、对象的扩展 5、函数的扩展 6、for...of

二、清除浮动的几种方法? (至少写3 种)
	1、给谁清除浮动，就在其后额外添加一个空白标签 2、父级添加overflow方法 3、使用after伪元素清除浮动 4、使用before和after双伪元素清除浮动
		 .clearfix: before,.clearfix:after{
                       content :""
                       display: table;
		 }
                 .clearfix:after{
                       clear: both ;
		 }
		 .clearfix{
		       *zoom:1;
		 }

三、CSS3有哪些新特性? (至少写出 3种)
	过度、动画、形状转换、选择器、阴影、边框、背景、反射、文字、颜色、渐变、滤镜、弹性布局、栅格布局、多列布局、盒模型定义、媒体查询

四、vue-router 有哪几种导航钩子?
	1、全局守卫： router.beforeEach

	2、全局解析守卫： router.beforeResolve

	3、全局后置钩子： router.afterEach

	4、路由独享的守卫： beforeEnter

	5、组件内的守卫： beforeRouteEnter、beforeRouteUpdate (2.2 新增)、beforeRouteLeave

五、Javascript 字符串操作函数有哪些?(至少写出3种)
	1、字符串转换
	2、字符串分割
	3、获取字符串长度
	4、查询字符串
	5、字符串替换
	6、查找给定位置的字符或其字符编码值
	7、字符串连接
	8、字符串切割和提取
	9、字符串大小写转换

六、什么是跨域，如何实现跨域访问? (至少写出3种)
	1、JSONP跨域：利用script脚本允许引用不同域下的js实现的，将回调方法带入服务器，返回结果时回调
	2、使用 CORS使用普通的 XMLHttpRequest 发起请求和获取数据

七、请简述Vue的双向数据你定原理是什么？
	Vue的双向绑定实现主要依赖于三个方面：数据监听（observer）、指令解析（compile）、观察订阅（watcher）
	在数据渲染时使用prop渲染数据，将prop绑定到子组件自身的数据上，修改数据时更新自身数据来替代prop，watch子组件自身数据的改变，触发事件通知父组件更改绑定到prop的数据。

	Vue数据绑定的好处是？
		父组件数据改变时，不会修改存储prop的子组件数据，只是以子组件数据为媒介，完成对prop的双向修改。
	
八、闭包的3特性?

	（1） 闭包是指有权访问另一个函数作用域中的变量的函数。（这与当函数被调用是会创建一个执行函数和相应的作用域链。作用域链本质上是指向变量对象的指针列表，只引用，不实际包含变量对象）。作用域链中，函数内部变量对象优先级最高，然后，由最近的外部函数依次向后排。

	（2） 封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口； 持久性：一般的函数，调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在。

	（3） 缺点：由于闭包携带包含它函数的作用域，因此比其他函数占用的内存更多。

优点：减少创建全局变量 减少传递给函数的参数量 封闭性

	（4）闭包可以读取函数内部的局部变量；这些变量的值始终保存在内存中

函数执行后，函数执行环境的作用域会被销毁，但是活动对象不会销毁，只有将匿名函数销毁后才可以销毁活动对象。可以将保存函数的变量赋值为null，将可销毁匿名函数作用域。

常见创建闭包方法：在一个函数内部创建另一个函数。

九、var numbers= [1,2,3,41;将numbers转换成“_”连接起来的字符串。

十、请详细说下你对vue生命周期的理解?
	创建前/后： 在beforeCreated阶段，vue实例的挂载元素$el和**数据对象**data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。

	载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。

	更新前/后：当data变化时，会触发beforeUpdate和updated方法。

	销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在

十一、 请说下vue组件间的传值?
	1、父传子：在组件注册的时候必须要使用return去返回data对象；把父级的数据传递给子集；
子集要允许父级传递的数据。用props接受一下数据的传递；

	2、子传父：父组件里的数据直接写在一个对象里，把这个地址传给子组件，因为地址是不会变的，所有在子组件里改这个地址里的数据，那么这个地址里的数据就被改变了，那么子组件的值就传递给了父组件，也就是说让父组件和子组件共享一个数据地址；

	3、在父组件定义一个函数，传给子组件该函数，子组件将数据作为该函数的参数调用，通过该函数就传递了子元素的数据，从而达到了子组件向父组件传值的目的。

	4、在第三种方法的基础上进行简化，不需要用props接收，而用emit接收父组件传来的函数，emit可以直接调用父组件传来的函数，第一个参数是函数名字，第二个参数是子元素传进去的参数。


十二、浏览器本地存储有哪几种,区别是什么?

	1、cookies： 在HTML5标准前本地储存的主要方式，优点是兼容性好，请求头自带cookie方便，缺点是大小只有4k，自动请求头加入cookie浪费流量

	2、localStorage：HTML5加入的以键值对(Key-Value)为标准的方式，优点是操作方便，永久性储存（除非手动删除），大小为5M，兼容IE8+

	3、sessionStorage：与localStorage基本类似，区别是sessionStorage当页面关闭后会被清理，而且与cookie、localStorage不同，他不能在所有同源窗口中共享，是会话级别的储存方式




